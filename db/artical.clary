{"curindex":7,"data":[{"_id":"aca85a562f9714c092e942171698e6dc","id":1,"seo_url":"hello-world","title":"“hello, world” 起源及其他","intro":"在IT界，hello world向世界打招呼成为惯例","author":"wangcl","thumbnail":"1.jpg","content":"###　问题的提出\r\n　　相传古时候有个退休的程序员，在家闲来无事，决定修习书法之道。第一日，备好笔墨纸砚，便挥毫写下一行大字：“hello, world”。\r\n\r\n　　学过编程语言的人都笑了，在程序员心目中，hello world是一切的开始，程序语言教科书的第一个演示程序、WordPress的第一篇示例文章（我的hello world）、环境搭建成功后的第一个测试…\r\n\r\n　　可是，为什么呢？为什么都用”hello,world”来做程序语言的入门程序，以及其他这一切的开始呢？\r\n\r\n###　hello,world 起源\r\n\r\n　　可能还需要解释一下什么是“hello,world”：hello world是一个简短的小程序，其功能是在显示设备上输出一行“hello,world”。几乎每一个程序设计语言的教材中的第一个范例都是hello world程序，因此在学习一门新语言的时候用hello world作为起步已经成为计算机程序界的一个传统。\r\n\r\n　　hello world的起源要追溯到1972年，贝尔实验室著名研究员Brian Kernighan在撰写“B语言教程与指导(Tutorial Introduction to the Language B)”时初次使用（程序），这是目前已知最早的在计算机著作中将hello和world一起使用的记录。之后，在1978年，他在他和Dennis Ritchie合作撰写的C语言圣经“The C Programming Language”中，延用了“hello,world”句式，作为开篇第一个程序。在这个程序里，输出的”hello,world”全部是小写，没有感叹号，逗号后有一空格。虽然之后几乎没能流传下来这个最初的格式，但从此用hello world向世界打招呼成为惯例。\r\n\r\n临时测试文案","seo_title":"","seo_keyword":"","seo_description":"","params":"insert","updatetime":1425315223325,"createtime":1425223208256,"serial":0,"clicknum":0,"status":0},{"_id":"8a57e6ab107de8707ebe74a50076664e","id":5,"seo_url":"nodejs-mongoose-introdution","title":"mongoose入门学习","intro":"nodejs的数据库相关，mongoose入门学习","author":"wangcl","thumbnail":"5.jpg","content":"最近使用express+mongoose来搭建OA,发现mongoose真是的好东西，能建模，单单此功能就爱不射手了。\r\n\r\n### 基本用法\r\n\r\n首先先安装mongoose的相关依赖\r\n\t\r\n    $ npm install mongoose --save\r\n    \r\n下面将是基本调用方法，先建个Person的Model，通过Person的Model初始化实例，实例自带保存事件。\r\n\r\n\tvar mongoose = require(\"mongoose\");\r\n\tmongoose.connect(\"mongodb://localhost/test\");\r\n\tvar Person = mongoose.model(\"Person\", {  \r\n    \tname: String,  \r\n    \tage: Number  \r\n\t});  \r\n\tvar clary = new Person({  \r\n    \tname: \"clary\",  \r\n    \tage: \"11\"  \r\n\t});  \r\n\tclary.save(function(err){  \r\n    \tif(err) // do errorthing;  \r\n    \t// do something;  \r\n\t});  \r\n\r\n### Model增删查改\r\n数据库操作最基本的就是增删查改了，上面说了简易的保存（增），接下来将做Model的删查改。\r\n\r\n+ 删除\r\n\r\n官方API：  \r\n\r\n\tModel#remove([fn])\r\n\tRemoves this document from the db.\r\n\tParameters:\r\n\t[fn] <Function> optional callback\r\n    \r\n实例，删除Person模型的数据：\r\n\r\n\tPerson.remove(function(err, data){\r\n    \tif(err) // do errorthing;\r\n    \t// data is del-data, do something;\r\n\t});\r\n    \r\n+ 查找\r\n\r\n官方API：\r\n\r\n\tModel.find(conditions, [fields], [options], [callback])\r\n\tFinds documents\r\n\tParameters:\r\n\tconditions <Object>\r\n\t[fields] <Object> optional fields to select\r\n\t[options] <Object> optional\r\n\t[callback] <Function>\r\n\tReturns:\r\n\t<Query>\r\n    \r\n实例，查找Person模型中所有数据：\r\n\r\n\tPerson.find({}, {}, {}, function(err, data){\r\n    \tif(err) // do errorthing;\r\n    \t// data is all-data, do something;\r\n\t});\r\n    \r\n+ 修改\r\n\r\n官方API：\r\n\r\n\tModel.update(conditions, update, [options], [callback])\r\n\tUpdates documents in the database without returning them.\r\n\tParameters:\r\n\tconditions <Object>\r\n\tupdate <Object>\r\n\t[options] <Object>\r\n\t[callback] <Function>\r\n\tReturns:\r\n\t<Query>\r\n    \r\n实例，修改Person模型中的某条数据\r\n\r\n\tPerson.update({\r\n    \tage: { $gt: 18 }\r\n\t}, {\r\n    \tage: 20\r\n\t}, {}, function(err, numberAffected, raw){\r\n    \tif(err) // do errorthing;\r\n    \tconsole.log(\"The number of updated record was %d\", numberAffected);\r\n    \tconsole.log(\"raw data was \", raw);\r\n\t});\r\n\r\n\r\n### 通过数据模型为实例设置事件\r\n\r\n\tPerson.methods.constellation = function(){\r\n    \tconsole.log(this); // 实例数据\r\n    \tconsole.log(\"My constellation is \" + str);\r\n\t}\r\n\tvar clary = new Person(...);\r\n\tclary.constellation();\r\n    \r\n\r\n### 建模微进阶，架构数据在建模\r\n+ 一阶建模\r\n\r\n\r\n\tvar PersonSchema = mongoose.Schema({\r\n\t\tname: String,\r\n\t\tage: Number\r\n\t});\r\n\tvar Person = mongoose.model(\"Person\", PersonSchema);\r\n    \r\n+ 多阶建模\r\n\r\n\r\n\tvar actionSchema = mongoose.Schema({\r\n\t\twalk: Function,\r\n\t\tHeight: Number\r\n\t});\r\n\tvar PersonSchema = mongoose.Schema({  \r\n\t\tname: String,  \r\n\t\tage: Number,  \r\n\t\taction: [actionSchema]  \r\n\t});  \r\n\tvar Person = mongoose.model(\"Person\", PersonSchema);  \r\n\r\n### 关联查询新增保存删除\r\n　　mongodb是非关系型数据，但在实际项目中仍有可能需要互相关联  \r\n目前较好的关联有，如下：\r\n+ 在建库时，调整建模的架构为最优（不用说也知道）\r\n+ 利用ref来关联两个model\r\n\r\n\r\n\tvar Schema = mongoose.Schema();\r\n\tvar PersonSchema = new Schema({\r\n\t\tname: String,\r\n    \tage: Number,\r\n    \tphone_id: [{ type: Schema.types.ObjectId, ref: \"Study\" }]\r\n\t});\r\n\tvar Person = mongoose.model(\"Person\", PersonSchema);\r\n\tvar PhoneSchema = new Schema({\r\n\t\ttelephone: Number,\r\n    \tparent_id: { type: Schema.types.ObjectId, ref: \"Person\" }\r\n\t});\r\n\tvar Phone = mongoose.model(\"Phone\", PhoneSchema);\r\n\r\n> 人有多个手机，这个手机只有一个人用，即有：  \r\n> Person => [Phone,Phone...], Phone => Person  \r\n> 所以Phone_id是一个数组，存储Phone的_id的集合  \r\n> 而parent_id只能存储单个Person的_id  \r\n> 模拟数据开始：\r\n\r\n\r\n\tPerson.create({\r\n\t\tname: “clary”,\r\n    \tage: 18\r\n\t}).save();\r\n\t// 生成一条数据\r\n\t// _id: 8ur8wuer9u98u3r89823ur8\r\n\t// name: clary\r\n\t// age: 18\r\n    // phone_id: []\r\n    Phone.create({\r\n        telephone: 17788889999,\r\n        parent_id: \"8ur8wuer9u98u3r89823ur8\" //作用：查询phone时能反向查到使用该手机的人\r\n    }).save(function(err, data){\r\n        // 保存玩手机后，把手机的_id写入的Person的phone_id中\r\n        if(err) {} // do something\r\n        Person.findById(\"8ur8wuer9u98u3r89823ur8\", function(err, doc){\r\n            if(err) {} // do something\r\n            doc[0].phone_id.push(data._id);\r\n            doc.save();\r\n        })\r\n    });\r\n    // 存第二个手机\r\n    Phone.create({\r\n        telephone: 17788880000,\r\n        parent_id: \"8ur8wuer9u98u3r89823ur8\"\r\n    }).save(function(err, data){\r\n        if(err) {} // do something\r\n        Person.findById(\"8ur8wuer9u98u3r89823ur8\", function(err, doc){\r\n            if(err) {} // do something\r\n            doc[0].phone_id.push(data._id);\r\n            doc.save();\r\n        })\r\n    });\r\n    // 当前Phone数据\r\n    var p = [\r\n        {\r\n            _id: \"df84gdf8gdfg9883dfdfg3f\",\r\n            telephone: 17788889999,\r\n            parent_id: \"8ur8wuer9u98u3r89823ur8\"\r\n        },\r\n        {\r\n            _id: \"2u9849q209u8eru98238rur\",\r\n            telephone: 17788880000,\r\n            parent_id: \"8ur8wuer9u98u3r89823ur8\"\r\n        }\r\n    ];\r\n    // 当前Person数据\r\n    var c = [\r\n        {\r\n            _id: \"8ur8wuer9u98u3r89823ur8\",\r\n            name: \"clary\",\r\n            age: 18,\r\n            phone_id: [\r\n                \"df84gdf8gdfg9883dfdfg3f\",\r\n                \"2u9849q209u8eru98238rur\"\r\n            ]\r\n        }\r\n    ]\r\n    // 模拟数据完毕，开始查询\r\n    Person.find() // 先查询person\r\n        .populate(\"phone_id\") // 填充person的ref关联的model数据\r\n        .exec(function(err, data){\r\n            if(err) {} // do something\r\n            console.log(data);\r\n        });\r\n    //输出结果如下：\r\n    var c = [\r\n        {\r\n            _id: \"8ur8wuer9u98u3r89823ur8\",\r\n            name: \"clary\",\r\n            age: 18,\r\n            phone_id: [\r\n                {\r\n                    _id: \"df84gdf8gdfg9883dfdfg3f\",\r\n                    telephone: 17788889999,\r\n                    parent_id: \"8ur8wuer9u98u3r89823ur8\"\r\n                },\r\n                {\r\n                    _id: \"2u9849q209u8eru98238rur\",\r\n                    telephone: 17788880000,\r\n                    parent_id: \"8ur8wuer9u98u3r89823ur8\"\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n \r\n","seo_title":"","seo_keyword":"","seo_description":"","params":"insert","updatetime":1426661654128,"createtime":1425918504634,"serial":0,"clicknum":0,"status":0},{"_id":"5f63aa2010a8a276c4db7780d8c45ccd","id":6,"seo_url":"nodejs-express-restful-api-method","title":"利用nodejs的express来开发rest api","intro":"restful web服务已成为热销的api，nodejs也是前端目前唯一的后台，将用此来开发restful api","author":"wangcl","thumbnail":"6.jpg","content":"### 基于nodejs搭建Rest Api\r\n#### 概述\r\n\r\n　　Rest是用资源的角度来观察整个网络，所有资源都通过URI来确定。  \r\n　　RESTful Web 服务（也称为 RESTful Web API）是一个使用HTTP并遵循REST原则的Web服务。它从以下三个方面资源进行定义：URI，比如：http://example.com/resources/。  \r\n　　对资源的操作包括获取、创建、修改、删除，刚好对应GET、POST、PUT、DELETE方法\r\n  \r\n#### REST开发\r\n利用express及其expressjs中间件来创建api  \r\nexpressjs需要中间件有：\r\n+ body-parser 解析来自客户端的request.body或req.body\r\n+ method-override 解析来自客户端method，使用方式app.get or app.post等等\r\n+ morgan 日志中间件，方便看请求是来自GET或POST或PUT或DELETE\r\n\r\n\tvar express = require(\"express\")\r\n\t\t, bodyParser = require(\"body-parser\")\r\n    \t, methodOverride = require(\"method-override\")\r\n    \t, logger = require(\"morgan\");\r\n\tvar app = express();\r\n\tapp.use(logger(\"dev\"));\r\n\tapp.use(bodyParser());\r\n\tapp.use(methodOverride());\r\n\tapp.route(\"/restful/clary/artical\")\r\n\t\t.get(function(req, res){ ... })\r\n    \t.post(function(req, res){ ... })\r\n    \t.put(function(req, res){ ... })\r\n    \t.delete(function(req, res){ ... })\r\n    \t.all(function(req, res){ ... });\r\n\tapp.listen(\"80\", function(){\r\n\t\tconsole.log(\"listent to 80\");\r\n\t});\r\n\r\n#### 测试Rest\r\n\r\n+ chrome工具：hostman，自己代理来测试\r\n+ jquery的ajax测试  \r\n\r\n通过不同的type类型来分别请求GET、POST、PUT、DELETE\r\n\r\n\r\n\t$.ajax({\r\n\t\turl: \"/restful/clary/artical\",\r\n    \ttype: \"GET\", // GET、POST、PUT、DELETE\r\n    \tdata: {\r\n    \t\ttitle: \"测试标题\",\r\n        \tcontent: \"测试内容\"\r\n    \t},\r\n    \tsuccess: function(data){\r\n    \t\tconsole.log(\"success\");\r\n        \tconsole.log(data);\r\n    \t},\r\n    \terror: function(){\r\n\t\t\tconsole.log(\"error\");\r\n\t\t}\r\n    });","seo_title":"","seo_keyword":"","seo_description":"","params":"insert","updatetime":1426661128872,"createtime":1426087476246,"serial":0,"clicknum":0,"status":0},{"_id":"460499a646aea70898e8fddc040d5cc2","id":7,"seo_url":"nodejs-mongoose-query","title":"mongoose常见查询","intro":"mongoose查询类型多、复杂，故例举常用查询","author":"wangcl","thumbnail":"7.jpg","content":"## mongoose各类查询，从基础到进阶\r\n\r\n> 先初始化一个名为User的Model  \r\n> 它有子文档articalSchema.\r\n\r\n\tvar articalSchema = new Schema({\r\n    \tartical_id: Number,\r\n    \ttitle: String,\r\n        content: String\r\n    });\r\n\tvar UserSchema = new Schema({\r\n    \tuid: Number,\r\n        name: String,\r\n        age: Number,\r\n        artical: [articalSchema]\r\n    });\r\n    var User = mongoodb.model(\"User\", UserSchema);\r\n\r\n> 给它初始化数据，如下：\r\n\r\n\t[\r\n    \t{\r\n        \tuid: 763781,\r\n            name: \"clary\",\r\n            age: 33,\r\n            artical: [\r\n            \t{\r\n                \tartical_id: 0,\r\n                    title: \"打字好累\",\r\n                    content: \"脑动即生字！\"\r\n                },{\r\n                \tartical_id: 2,\r\n                    title: \"还要继续打\",\r\n                    content: \"打了呱呱叫\"\r\n                }\r\n            ]\r\n        },{\r\n        \tuid: 763782,\r\n            name: \"iam\",\r\n            age: 22,\r\n            artical: [\r\n            \t{\r\n                \tartical_id: 1,\r\n                    title: \"打字好累copy\",\r\n                    content: \"脑动即生字！copy\"\r\n                },{\r\n                \tartical_id: 3,\r\n                    title: \"还要继续打copy\",\r\n                    content: \"打了呱呱叫copy\"\r\n                }\r\n            ]\r\n        }\r\n    ]\r\n\r\n> 查询API：查询子文档\r\n\r\n\tUser.find() // 查询出query\r\n    \t.where(\"artical\").elemMatch({\r\n        \tartical_id: 3\r\n        }) // 对子文档进行查询\r\n        .exec(function(err, data){\r\n        \tconsole.log(data);\r\n            // data是artical_id==3的User记录集合\r\n        });\r\n\r\n> 查询API：条件查询\r\n\t\r\n    User.find()\r\n        .where(\"age\").gte(5).lte(18) // 5<=age<=18\r\n        .where(\"name\").in([\"clary\", \"iam\"]) // name在数组中出现的数据\r\n        .select(\"uid\", \"name\") // 查出的集合只包含uid和name两个字段\r\n        .asc(\"age\") // 对age进行排序查询\r\n        .exec();\r\n\r\n> 查询API：分页查询\r\n\t\r\n    var page = page || 1; // 默认请求第一页\r\n    var limit = limit || 10; // 默认每页记录数为10\r\n    User.find()\r\n    \t.where({}) // 先筛选出自己想要的数据\r\n        .skip( (page-1)*10 ) // 从第(page-1)*10条记录开始查询，第一页即从第一条开始查询\r\n        .limit(limit) // 只取limit条记录\r\n        .exec(function(err, data){\r\n        \t// do something\r\n        })\r\n","seo_title":"","seo_keyword":"","seo_description":"","params":"insert","updatetime":1426660949587,"createtime":1426660380960,"serial":0,"clicknum":0,"status":0}]}